# 成果验收
各位老师好，我本次毕业设计的题目是Linux服务器监控告警系统的设计与实现。  
**（draw.io模块划分图）**  

## 模块划分
系统整体分为监控采集模块，数据存储与处理模块，还有可视化模块三个部分，开发时是按照模块划分独立进行开发的。  
**（转浏览器GitHub页面）**  
它们分别对应着GitHub上的这三个仓库，首先是监控采集模块，然后数据存储与处理模块，最后是可视化模块。第四个仓库的话是开发过程中整理出来的相关文档，deploy目录下是部署过程中用到的脚本和配置文件，doc目录下是开发过程中的一些笔记。  

## 线上部署
**（draw.io部署结构图）**  
在完成了各个模块的代码实现之后，我借助自己已有的服务器进行了部署，这边是具体的部署方式。  
* 首先的话是一台1核2G内存的阿里云学生机作为主服务器，在上面我利用了Docker提供Redis和TimescaleDB数据库服务，同时部署了两个数据存储与处理模块，一个监听3000端口，一个监听3001端口，然后利用Nginx对这两个数据存储与处理模块进行负载均衡，同时它也为前端的可视化模块提供静态文件服务。主服务器上的话我也部署了一个监控采集模块用来收集主服务器运行的一些相关信息。  
* 下面这些是其它的被监控服务器，其中包括了华为云的一台ARM架构的服务器，用来测试监控采集模块的交叉编译效果；然后本地的这台开发机，一会儿方便进行告警测试；接着三个常见Linux发行版的虚拟机，
**（Ctrl + F2 切虚拟机页面再切回来）**  
用来测试监控采集模块的兼容性；最后是自己的博客服务器，位于海外，用来测试网络延迟对监控数据的上报是否有影响。  

## 功能演示
接下来我演示一下该系统的主要功能。  
**（浏览器首页）**  
这边是可视化模块的首页，做了一个简单的身份认证，可以看到此时的注册功能是被管理员关闭着的。登录页面这里输入邮箱和密码可以进行登录。登录之后会出现控制台的入口，进入控制台这边是默认的一个概览页面，上面的三个统计信息方便管理员对系统的整体运行状态有一个大致的认识，然后下面是最近使用过的主机和规则组的快速入口。  
然后看一下主机列表，这里面的话一共是7台主机，就分别对应着部署时提到的7台被监控服务器。  
**（draw.io部署结构图）**  
以阿里云的这台主服务器为例，查看主机详情，上面的话是主机的基本信息，有IP地址，操作系统，内核版本等，下面是监控采集模块所收集到的具体的监控数据，包含了CPU使用率，内存利用率，平均负载，后面还有网络带宽和磁盘读写的相关统计，最下面是挂载点，SSH登录事件，还有文件修改事件。这里默认显示的是最近一个小时内的监控数据，也提供了其他的几个预设时间段方便进行调整，这边也可以自定义具体的时间段。右上角的刷新按钮可以刷新下方的所有监控图表。  
然后我们把时间段切换到14天看一下，14天的话可以看到内存利用率这里有两个明显的断崖，第一个是因为最初使用Docker部署TimescaleDB数据库时，它默认认为服务器上只运行了自己一个服务，所以会最大化地利用主服务器的所有可用内存，通过该监控告警系统注意到主服务器的内存利用率一直在上升后，对TimesclaeDB的配置进行了优化，之后主服务器的内存利用率就稳定多了。第二个断崖是在准备成果验收前，结束掉了阿里云主服务器上的一些其它无关服务，释放出了更多可用内存。  
自定义区间这里我们是可以任意调整的，例如现在是（xx点xx），调整为（xx点xx）到现在，一共是x分钟内的数据，随着区间的减小，监控图表上的数据也会更加精确，现在两个监控点之间的时间间隔是10秒。  
主机相关信息介绍完了我们来看一下监控告警部分。  
**（draw.io规则组说明）**  
这里为了方便对主机进行批量管理，定义了一个“规则组”的概念，规则组的具体设计如图所示：  
* 被监控主机，规则组，推送三者相互独立，上下两者与规则组之间都是多对多的关系，例如一个规则组内可以包含多个主机，一个主机也可以加入多个规则组。  
* 监控组与监控规则之间属于一对多，也就是说一条监控规则只能属于一个规则组，一个规则组内能够包含多条监控规则。  

**（浏览器规则管理页面）**  
可视化模块这里的规则管理显示的就是所有的规则组，在操作这里可以选择查看详情，就是查看规则组内已有的规则。这里的管理主机就是向规则组添加删除主机，点击添加按钮可以看到主机列表里尚未添加进来的所有主机，已添加的主机也可以随时删除。然后规则组这里还有一个管理推送，推送的话在这边有一个推送管理，因为推送和规则组之间也是相互独立的，所以系统的所有推送在这里集中进行管理。这里可以看到系统的所有推送，可以新建，也可以编辑或删除已有的推送。然后规则组的管理推送就是从系统的所有推送中向规则组添加推送或者删除规则组已有推送。  
回到规则管理这边，再来详细地看一下监控规则。例如这里的第三个规则组，点击查看详情，可以看到规则组中包含的具体监控规则，第一条是CPU使用率在20秒内平均值达到60%触发告警，静默时间为60秒，第二条是系统的一分钟平均负载达到5时触发告警，静默时间同样也是60秒，右下角这里可以添加新的规则，选择完生效目标后会有不同的触发事件，然后可以设定的项有阈值，计算时间，静默时间，提醒等级，上面已有的规则也是可以再次编辑的。  
接下来我将使用本地的开发机进行一个告警测试，开发机的话对应这里的三号主机。  
**（本地开发机详情页）**  
切到本地开发机的详情页，CPU使用率这里开始录屏后提高到了20%，内存利用率在70%左右。已用规则这里可以看到对该主机已生效的规则，也可以跳转到对应规则组或者查看推送者，这里将CPU使用率的阈值改为40%方便触发，返回详情页。  
**（scrcpy手机画面）**  
这里是我手机上的实时画面，接下来的告警推送均会推送到手机。  
我这里使用Linux下的一个stress命令来增加CPU负载，右下角可以看到实时的CPU和内存占用，在可视化模块上也可以看到了CPU利用率的升高，接下来稍等一会儿，手机上已经收到了告警推送，这个是邮件通知，这个是飞书的通知，然后还有钉钉和企业微信。  
回到这边的可视化模块，再次刷新页面，可以看到主机状态已经发生了改变，主机列表中也有明显的标识，如果报警相关问题已被修复的话，管理员可以在这里手动恢复主机状态。开发机的报警历史中最新的这两条就是刚刚的告警信息，xx点xx和xx点xx，监控告警功能测试完毕。  
最左边的导航栏还有警报历史，显示的是系统中的所有历史警报，最后一个是系统设置，当前是有一个禁止注册的选项，用来禁止无关用户注册。  

## 服务器展示
接下来看一下双数据存储与处理模块的负载均衡效果，先在主机详情这里多刷新几次，增加请求次数，一会儿可以在服务器上查到两个模块各自处理的请求数。通过SSH连接上阿里云主服务器，使用curl命令访问数据存储与处理模块预留的状态接口，可以看到监控端的7个WebSocket连接是较均匀分布的，少了一个连接的模块也会负责处理更多的HTTP请求，负载均衡效果还是不错的。

然后我们关闭掉一个数据存储与处理模块，再次通过状态接口查看模块运行情况，可以看到被关掉的模块上的WebSocket连接重连后都被分配到了剩余的一个模块上，重新启动二号模块后再重启Nginx服务，Nginx服务的重启会导致所有Websocket连接的断开，然后触发断线重连，再次通过状态查询接口进行查询，负载均衡正常发挥作用。

部署地址是 xxx.xxx.xxx.xxx ，我这里提供了一个测试帐号，老师们可以随时使用测试帐号登录查看。  
邮箱：xxxxxxxx  
密码：xxxxxxxx

我的成果展示到此结束，感谢老师们的观看。  
